<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1.0, width=device-width" />
    <link rel="stylesheet" href="indexContent.css">
</head>
<body>
<header class="first">
    <div id="home"><a href="index.html">HOME</a></div>
    <div id="back"><a href="#home">↑</a></div>
    <section>
        <a href="allNavigation.html"><header>NAVIGATION</header></a>
        <ul>
            <li><a href="#set" id="set">各种集合</a></li>
            <li><a href="#book" id="book">看书学习</a></li>
            <li><a href="#blog" id="blog">博客搭建</a></li>
        </ul>
        <div class="clear"></div>
    </section>
</header>
<section class="CONTENT">
    <section>
        <content class="right">
            <h1>探索Git(16)——rebase和merge区别</h1>
            <header class="content">
            </header>
            <article>
                <h4>0.git rebase</h4>
                <p>git rebase命令在另一个分支基础之上重新应用，用于把一个分支的修改合并到当前分支。</p>
                <h5>使用语法</h5>
                <p class="code">
                    git rebase [-i | --interactive] [options] [--exec 《cmd》] [--onto 《newbase》]<br>
                    [《upstream》 [《branch》]]<br>
                        git rebase [-i | --interactive] [options] [--exec 《cmd》] [--onto 《newbase》]<br>
                            --root [《branch》]<br>
                                git rebase --continue | --skip | --abort | --quit | --edit-todo
                </p><br>
                <h5>示例</h5>
                <p>假设你现在基于远程分支”origin“，创建一个叫”mywork“的分支。</p>
                <p class="code">$ git checkout -b mywork origin</p>
                <img src="picture/fiftySeventh1.jpg">
                <p>现在我们在这个分支(mywork)做一些修改，然后生成两个提交(commit).</p>
                <p class="code">
                    $ vi file.txt<br>
                    $ git commit<br>
                    $ vi otherfile.txt<br>
                    $ git commit<br>
                    ... ...
                </p><br>
                <p>
                    但是与此同时，有些人也在”origin“分支上做了一些修改并且做了提交了，
                    这就意味着”origin“和”mywork“这两个分支各自”前进”了，它们之间”分叉”了。
                </p>
                <img src="picture/fiftySeventh2.jpg">
                <p>
                    在这里，你可以用”pull“命令把”origin“分支上的修改拉下来并且和你的修改合并； 结果看起来就像一个新的”合并的提交”(merge commit):
                </p>
                <img src="picture/fiftySeventh3.jpg">
                <p>
                    但是，如果你想让”mywork“分支历史看起来像没有经过任何合并一样，也可以用 git rebase，如下所示:
                </p>
                <p class="code">
                    $ git checkout mywork<br>
                    $ git rebase origin
                </p><br>
                <p>
                    这些命令会把你的”mywork“分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到”.git/rebase“目录中),
                    然后把”mywork“分支更新 到最新的”origin“分支，最后把保存的这些补丁应用到”mywork“分支上。
                </p>
                <img src="picture/fiftySeventh4.jpg"/>
                <p>
                    当’mywork‘分支更新之后，它会指向这些新创建的提交(commit),而那些老的提交会被丢弃。 如果运行垃圾收集命令(pruning garbage collection),
                    这些被丢弃的提交就会删除.
                </p>
                <img src="picture/fiftySeventh5.jpg"/>
                <h4>1.用合并(merge)和用rebase所产生的历史的区别：</h4>
                <img src="picture/fiftySeventh6.jpg"/>
                <p>
                    在rebase的过程中，也许会出现冲突(conflict)。在这种情况，Git会停止rebase并会让你去解决冲突；
                    在解决完冲突后，用”git add“命令去更新这些内容的索引(index), 然后，你无需执行 git commit,只要执行:
                </p>
                <p class="code">$ git rebase --continue</p>
                <p>
                    这样git会继续应用(apply)余下的补丁。
                </p>
                <h5>在任何时候，可以用--abort参数来终止rebase的操作，并且”mywork“ 分支会回到rebase开始前的状态。</h5>
                <p class="code">$ git rebase --abort</p>
            </article>
        </content>
    </section>
    <aside class="left">
        <h2>其他文章推荐</h2>
        <nav>
        </nav>
    </aside>
    <div></div>
</section>
<section class="cut">
</section>
<script src="jquery-3.2product.js"></script>
<script src="a.js"></script>
<script src="content.js"></script>
</body>